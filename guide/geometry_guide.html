

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Tomographic acquisition geometries &mdash; odl 1.0.0.dev0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Functional" href="functional_guide.html" />
    <link rel="prev" title="Vectorized functions" href="vectorization_guide.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> odl
          

          
          </a>

          
            
            
              <div class="version">
                1.0.0.dev0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/getting_started.html">Getting Started</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with ODL</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="guide.html">User’s guide – selected topics</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="operator_guide.html">Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="linearspace_guide.html">Linear spaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="numpy_guide.html">Using ODL with NumPy and SciPy</a></li>
<li class="toctree-l2"><a class="reference internal" href="vectorization_guide.html">Vectorized functions</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Tomographic acquisition geometries</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#geometry-and-data-structure">Geometry and data structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="#representation-using-euclidean-domains">Representation using Euclidean domains</a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometries-in-odl">Geometries in ODL</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-geometry-class">The <code class="docutils literal notranslate"><span class="pre">Geometry</span></code> class</a></li>
<li class="toctree-l4"><a class="reference internal" href="#geometric-definitions-and-conventions">Geometric definitions and conventions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#detector-properties">Detector properties</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="functional_guide.html">Functional</a></li>
<li class="toctree-l2"><a class="reference internal" href="proximal_lang_guide.html">Using ODL with ProxImaL</a></li>
<li class="toctree-l2"><a class="reference internal" href="pdhg_guide.html">Primal-Dual Hybrid Gradient algorithm</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../math/math.html">Mathematical Background</a></li>
</ul>
<p class="caption"><span class="caption-text">Developer zone</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../dev/dev.html">Contributing to ODL</a></li>
</ul>
<p class="caption"><span class="caption-text">Useful facts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="faq.html">Frequently asked questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release_notes.html">Release Notes</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../refs.html">References</a></li>
</ul>
<p class="caption"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../odl.html">odl</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">odl</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="guide.html">User’s guide – selected topics</a> &raquo;</li>
        
      <li>Tomographic acquisition geometries</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/guide/geometry_guide.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="tomographic-acquisition-geometries">
<span id="geometry-guide"></span><h1>Tomographic acquisition geometries<a class="headerlink" href="#tomographic-acquisition-geometries" title="Permalink to this headline">¶</a></h1>
<p>This document is intended to introduce definitions and conventions used in ODL <a class="reference internal" href="../generated/odl.tomo.geometry.geometry.Geometry.html#odl.tomo.geometry.geometry.Geometry" title="odl.tomo.geometry.geometry.Geometry"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Geometry</span></code></a> classes that represent tomographic acquisition geometries.
The first part introduces the abstract description of data as a function on a data manifold and then shows how this representation is simplified by using a parametrization of the manifold with a tuple of real numbers.
The second part then describes the implementation of these concepts in ODL.</p>
<p>Acquisition geometries are a central part of the <code class="docutils literal notranslate"><span class="pre">odl.tomo</span></code> subpackage.
They specify the physical setup of tomographic measurements and thus encode the geometric information that is needed to relate measurement data to the precise configuration of the system that gave rise to this data.
This geometric configuration defines the relation between a (usually unknown) spatial distribution of a physical quantity, e.g., an attenuation coefficient, to measured data, e.g., how many photons were counted per pixel for given source and detector positions in a tomographic scanner.</p>
<div class="section" id="geometry-and-data-structure">
<h2>Geometry and data structure<a class="headerlink" href="#geometry-and-data-structure" title="Permalink to this headline">¶</a></h2>
<p>Mathematically, the interaction between probing rays and physical matter is often modeled as integration along straight lines.
The corresponding mathematical operation, called <strong>ray transform</strong>, incorporates all geometry information since it is usually defined as a mapping from a space of functions on <img class="math" src="../_images/math/d8694ed87c3529dd999c8d5ddad4e17badc958fc.png" alt="\mathbb{R}^d"/> to a space of functions on a <a class="reference external" href="https://en.wikipedia.org/wiki/Manifold">manifold</a> <img class="math" src="../_images/math/450a8e2c2320d77181e0d4fc68c947e9a5de8ecb.png" alt="M"/>, the <em>data manifold</em>.
This data manifold is typically a subset of the manifold of all lines in <img class="math" src="../_images/math/d8694ed87c3529dd999c8d5ddad4e17badc958fc.png" alt="\mathbb{R}^d"/>, and the value of a function in a certain point on that manifold corresponds to the value of the integral along that line.</p>
<p>For instance, in 2 dimensions and parallel beam geometry, i.e., a setup where all lines from a common direction are parallel, the ray transform can be defined as</p>
<blockquote>
<div><div class="math">
<p><img src="../_images/math/2a67a8b660095f16e846189b82685e7ce6454a42.png" alt="&amp;\mathcal{R} : L^2(\Omega) \to L^2(M),

&amp;\mathcal{R}(f)(\theta, v) := \int_{\mathbb{R}} f(v + t\theta)\, \mathrm{d}t,\quad \theta \in \Gamma \subset \mathbb{S}^1,\ v \in \theta^\perp,"/></p>
</div></div></blockquote>
<p>where <img class="math" src="../_images/math/ce33a3002b39699014bc7df6e9ad933a8b78d524.png" alt="\Omega \subset \mathbb{R}^2"/> is a bounded domain, <img class="math" src="../_images/math/4bb11db5b753b97650d760afd3690444b281d8c1.png" alt="\mathbb{S}^1"/> is the unit sphere in 2 dimensions and <img class="math" src="../_images/math/aa362896b11fb491458390b969f394886548e04b.png" alt="\theta^\perp = \{x \in \mathbb{R}^2\, |\, \langle x,\, \theta \rangle = 0\}"/> is the plane (=line) perpendicular to a vector <img class="math" src="../_images/math/3be04d4207434584251f6921820c24ac9fa8c6f1.png" alt="\theta"/>.
In this case, the data manifold is</p>
<blockquote>
<div><div class="math">
<p><img src="../_images/math/1d81c40f3d823910897e8c0d7e4c6e6b1bae33eb.png" alt="M = \big\{(\theta, v)\,\big|\, \theta \in \Gamma,\ v \in \theta^\perp \big\}"/></p>
</div></div></blockquote>
<p>and encodes the subset of lines in <img class="math" src="../_images/math/d9c346422780d56b8c09056c33fe54b64ed85c9b.png" alt="\mathbb{R}^2"/> that are parallel to a unit vector in <img class="math" src="../_images/math/d872993ed0c7c420e73e77a1d285ac100c516806.png" alt="\Gamma"/>.</p>
</div>
<div class="section" id="representation-using-euclidean-domains">
<h2>Representation using Euclidean domains<a class="headerlink" href="#representation-using-euclidean-domains" title="Permalink to this headline">¶</a></h2>
<p>Function spaces (discretized or continuous) in ODL are, up to a few exceptions, defined on rectangular domains.
Such spaces have a relatively simple structure and can be represented and manipulated very efficiently.
Therefore ODL does not represent data directly as functions on manifolds, but rather as functions on a <em>coordinate domain</em> that paremetrizes the manifold.</p>
<p>For instance, in the 2D parallel beam example above, a unit vector <img class="math" src="../_images/math/c2f3e6f1fdc3a18330d262a1d234769ab664d49f.png" alt="\theta \in \mathbb{S}^1"/> can be parametrized by an angle <img class="math" src="../_images/math/09e8ad73f0c6db587ed17a14ba12e8f8424065d7.png" alt="\varphi \in [0, 2\pi)"/>, and a vector <img class="math" src="../_images/math/8d230554a01423c4c6560104b2918b65607c9406.png" alt="v"/> on the line <img class="math" src="../_images/math/a019b9a48ed929e349612e8bbd33ec7002a92cde.png" alt="\theta^\perp"/> by a single number <img class="math" src="../_images/math/3f2ac9a2ab5982f4485436c94eb666086dd4f663.png" alt="s \in \mathbb{R}"/>.
Such a representation additionally requires a <em>convention</em> for a translation between coordinates <img class="math" src="../_images/math/1abbfd09733f16e53c70bb0e1d5c8b7b1093e501.png" alt="(\varphi, s)"/> and points <img class="math" src="../_images/math/53f59c88d534f3ce71577e47b011ce6a7b851483.png" alt="(\theta, v)"/> on the manifold, i.e., a map between the coordinate domain and the data manifold.
Such a map is usually called a <em>parametrization</em> or <a class="reference external" href="https://en.wikipedia.org/wiki/Manifold#Charts">chart</a> of the manifold.</p>
<p>In our example, we could thus redefine the ray transform as a map between Euclidean function spaces like this:</p>
<blockquote>
<div><div class="math">
<p><img src="../_images/math/30f9b192e5d52e05b31c6f902c5d1a5fbfad0a09.png" alt="&amp; \mathcal{R} :  L^2(\Omega) \to L^2(I \times D),

&amp; \mathcal{R}(f)(\varphi, u) := \int_{\mathbb{R}} f\big( u\theta(\varphi - \pi/2) + t\theta(\varphi) \big)\, \mathrm{d}t."/></p>
</div></div></blockquote>
<p>Here, <img class="math" src="../_images/math/c00d98c26940d1747c25ae0bfec02215cc94745b.png" alt="I \subset [0, 2\pi)"/> and <img class="math" src="../_images/math/3a43b076b72af8ede2015ca64911bca413021b00.png" alt="D \subset \mathbb{R}"/> are intervals and</p>
<blockquote>
<div><div class="math">
<p><img src="../_images/math/930d5302ac3b9a995e346cacc09b3adbb9d111e2.png" alt="&amp; (\varphi, u) \mapsto \big( \theta(\varphi), u \theta(\varphi - \pi/2)\big),

&amp; \theta(\varphi) := (-\sin\varphi, \cos\varphi)"/></p>
</div></div></blockquote>
<p>is a parametrization of the data manifold.</p>
<div class="figure align-center" id="id1">
<a class="reference internal image-reference" href="../_images/parallel2d_geom.svg"><img alt="../_images/parallel2d_geom.svg" src="../_images/parallel2d_geom.svg" width="75%" /></a>
<p class="caption"><span class="caption-text">Parametrization of lines in 2D parallel beam geometry.</span></p>
</div>
</div>
<div class="section" id="geometries-in-odl">
<h2>Geometries in ODL<a class="headerlink" href="#geometries-in-odl" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="../generated/odl.tomo.operators.ray_trafo.RayTransform.html#odl.tomo.operators.ray_trafo.RayTransform" title="odl.tomo.operators.ray_trafo.RayTransform"><code class="xref any py py-class docutils literal notranslate"><span class="pre">RayTransform</span></code></a> in ODL is an <a class="reference internal" href="glossary.html#term-operator"><code class="xref any std std-term docutils literal notranslate"><span class="pre">Operator</span></code></a> between <a class="reference internal" href="../generated/odl.discr.lp_discr.DiscreteLp.html#odl.discr.lp_discr.DiscreteLp" title="odl.discr.lp_discr.DiscreteLp"><code class="xref any py py-class docutils literal notranslate"><span class="pre">DiscreteLp</span></code></a> type discretized function spaces defined on rectangular domains.
The <strong>reconstruction space</strong> (“volume”), i.e., the <a class="reference internal" href="glossary.html#term-domain"><span class="xref std std-term">domain</span></a> of the ray transform, is naturally described as functions on a Euclidean space, and as derived above, the <strong>data space</strong>, i.e., the <a class="reference internal" href="glossary.html#term-range"><span class="xref std std-term">range</span></a> of the ray transform, can also be defined in terms of Euclidean coordinates.
The missing component, which is the mapping from coordinates to points on the data manifold, is encoded in the <a class="reference internal" href="../generated/odl.tomo.geometry.geometry.Geometry.html#odl.tomo.geometry.geometry.Geometry" title="odl.tomo.geometry.geometry.Geometry"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Geometry</span></code></a> class and its subclasses as described in the following.</p>
<div class="section" id="the-geometry-class">
<h3>The <a class="reference internal" href="../generated/odl.tomo.geometry.geometry.Geometry.html#odl.tomo.geometry.geometry.Geometry" title="odl.tomo.geometry.geometry.Geometry"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Geometry</span></code></a> class<a class="headerlink" href="#the-geometry-class" title="Permalink to this headline">¶</a></h3>
<p>All ODL geometries derive from the abstract <a class="reference internal" href="../generated/odl.tomo.geometry.geometry.Geometry.html#odl.tomo.geometry.geometry.Geometry" title="odl.tomo.geometry.geometry.Geometry"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Geometry</span></code></a> class that provides a basic structure.
Most attributes are intended to query for geometric information, e.g., source and detector positions and their orientations.
See the documentation of <a class="reference internal" href="../generated/odl.tomo.geometry.geometry.Geometry.html#odl.tomo.geometry.geometry.Geometry" title="odl.tomo.geometry.geometry.Geometry"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Geometry</span></code></a> and <a class="reference internal" href="../generated/odl.tomo.geometry.detector.Detector.html#odl.tomo.geometry.detector.Detector" title="odl.tomo.geometry.detector.Detector"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Detector</span></code></a> for details on the API.</p>
</div>
<div class="section" id="geometric-definitions-and-conventions">
<h3>Geometric definitions and conventions<a class="headerlink" href="#geometric-definitions-and-conventions" title="Permalink to this headline">¶</a></h3>
<p>Since one part of the geometry parameters usually refer to a system motion or transformation, they are called <strong>motion parameters</strong>.
For instance, in a 2D parallel beam geometry, the single motion parameter is the angle of rotation around the origin.
In general, they can refer to any encoding of the motion of the acquisition system.
The <em>initial state</em> of the system corresponds to motion parameters <img class="math" src="../_images/math/541e5f57428bd0242cfabceb57cd8f9a5d1f9d5b.png" alt="m = 0"/>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The above definition of the initial state does not imply that <img class="math" src="../_images/math/541e5f57428bd0242cfabceb57cd8f9a5d1f9d5b.png" alt="m = 0"/> must be in the set of valid parameters – it merely means that definitions are understood as relative to zero.</p>
</div>
<p>To determine the spatial position <img class="math" src="../_images/math/ab89306f25fbc2e387f742ce26e64864fd4e2ded.png" alt="p(m, u)"/> of a detector point at a given configuration, both motion parameter <img class="math" src="../_images/math/edba97b4c0d864d26e92ea7ea73767fa38eef3f7.png" alt="m"/> and detector parameter <img class="math" src="../_images/math/92e3f44c99a016c5238a790c96f12fd46aa93c4a.png" alt="u"/> need to be provided.</p>
<p>The vector pointing from the origin to a detector point is decomposed into two components:</p>
<ul class="simple">
<li>a detector reference point <img class="math" src="../_images/math/936abdab510792f8de90d43a0570d3bae8c80772.png" alt="r = r(m)"/> only depending on the motion parameter (<a class="reference internal" href="../generated/odl.tomo.geometry.geometry.Geometry.det_refpoint.html#odl.tomo.geometry.geometry.Geometry.det_refpoint" title="odl.tomo.geometry.geometry.Geometry.det_refpoint"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Geometry.det_refpoint</span></code></a>),</li>
<li>an <em>intrinsic</em> shift <img class="math" src="../_images/math/045a413882c25f0de6f1d5d13a6f2fdb0eb6b2c6.png" alt="s = s(u)"/> within the detector only depending on the detector parameter (<a class="reference internal" href="../generated/odl.tomo.geometry.detector.Detector.surface.html#odl.tomo.geometry.detector.Detector.surface" title="odl.tomo.geometry.detector.Detector.surface"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Detector.surface</span></code></a>).</li>
</ul>
<p>The total displacement is then given by</p>
<blockquote>
<div><div class="math">
<p><img src="../_images/math/f3e31cf601d1caa71d3fa38b2f6e63661651bf85.png" alt="p(m, u) = r(m) + R(m) s(u),"/></p>
</div></div></blockquote>
<p>where <img class="math" src="../_images/math/60aa7f3cd867cf4b20b36411cb4542603b823504.png" alt="R(m)"/> is a transformation of the detector reference system (in which <img class="math" src="../_images/math/ad98dbf41221f72019aa9b763c6a12a7f482fc8c.png" alt="s(u)"/> is defined) to the coordinate system at motion parameter <img class="math" src="../_images/math/edba97b4c0d864d26e92ea7ea73767fa38eef3f7.png" alt="m"/> (in particular, <img class="math" src="../_images/math/fa86872e1f97a2cfe7f5a51e096df0922394abf5.png" alt="R(0) = I"/>, the identity matrix).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Here and in the following, <em>intrinsic</em> transformations (such as shifts or rotations) mean transformations in the local coordinate system, while <em>extrinsic</em> transformations are relative to the global (“world”) coordinate system.
The extrinsic counterpart of an intrinsic transformation can be computed as follows:</p>
<p>Suppose <img class="math" src="../_images/math/a9a6bb9179513a2f7cc04cd8cc853690b6df1703.png" alt="t: \mathbb{R}^3 \to \mathbb{R}^3"/> is an intrinsic transformation and <img class="math" src="../_images/math/071de9c4143f5b3a1e2aba0d57bacf5cecdecf59.png" alt="C: \mathbb{R}^3 \to \mathbb{R}^3"/> the coordinate transform from world to local coordinates.
Then, the extrinsic variant <img class="math" src="../_images/math/f2d283a2071f9d043c9e0b0f794a8880fa0d3ce9.png" alt="T"/> of <img class="math" src="../_images/math/5ec053cf70dc1c98cc297322250569eda193e7a4.png" alt="t"/> is given as <img class="math" src="../_images/math/249309f64fd51218dc461848848a62cb8669ab1a.png" alt="T = C^{-1} \circ t \circ C"/>, i.e., world-to-local transform, followed by the local transform <img class="math" src="../_images/math/5ec053cf70dc1c98cc297322250569eda193e7a4.png" alt="t"/>, followed by the mapping <img class="math" src="../_images/math/a8ebdbc25ca4abaf2eecfb3f743bdc77806d12cc.png" alt="C^{-1}"/> back to world coordinates.</p>
<p class="last">The in-detector shift <img class="math" src="../_images/math/ad98dbf41221f72019aa9b763c6a12a7f482fc8c.png" alt="s(u)"/> above is given in local coordinates <img class="math" src="../_images/math/92e3f44c99a016c5238a790c96f12fd46aa93c4a.png" alt="u"/> and should be translated to global coordinates.
Therefore, only the left part <img class="math" src="../_images/math/0a810de4eae4b5bc5279336e368843dec905eeab.png" alt="\tilde T = C^{-1} \circ t"/> applies in that case.</p>
</div>
<p>In the 2d parallel beam example, <img class="math" src="../_images/math/50d39250864281af40002acc3b12bb759cad6f13.png" alt="r(m)"/> corresponds to <img class="math" src="../_images/math/1e76a471a08e08541c69090efaa96749514ce8f8.png" alt="\theta(\varphi)"/>.
Since <img class="math" src="../_images/math/b7d123348b1721baadd37a8e0009d4e1f3016bcc.png" alt="\theta(0) = (0, 1)"/> we assume that in its reference state the detector is aligned with the <img class="math" src="../_images/math/a59f68a4202623bb859a7093f0316bf466e6f75d.png" alt="x"/> axis, i.e., <img class="math" src="../_images/math/bc099d156540c299d6fd254756e25afd17ad195d.png" alt="s(u) = (u, 0)"/>.
The detector point at <img class="math" src="../_images/math/4a24541fb24a9a945e4e5b331fafc042762241ee.png" alt="(\varphi, u)"/> is now given by</p>
<blockquote>
<div><div class="math">
<p><img src="../_images/math/7c51f7e9897f95c3fba33f580a960a92de0d490a.png" alt="&amp; p(\varphi, u) = R(\varphi)
\begin{pmatrix}
    0 \\
    1
\end{pmatrix}
+ R(\varphi)
\begin{pmatrix}
    u \\
    0
\end{pmatrix},

&amp; R(\varphi) =
\begin{pmatrix}
    \cos\varphi &amp; -\sin\varphi \\
    \sin\varphi &amp; \cos\varphi
\end{pmatrix}"/></p>
</div></div></blockquote>
<p>The rotation matrix <img class="math" src="../_images/math/69a3937fbc6bc97aa28522c8bf8d6fe51d013837.png" alt="R(\varphi)"/> is exposed as <a class="reference internal" href="../generated/odl.tomo.geometry.geometry.Geometry.rotation_matrix.html#odl.tomo.geometry.geometry.Geometry.rotation_matrix" title="odl.tomo.geometry.geometry.Geometry.rotation_matrix"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Geometry.rotation_matrix</span></code></a>.</p>
<div class="section" id="determining-the-initial-configuration">
<h4>Determining the initial configuration<a class="headerlink" href="#determining-the-initial-configuration" title="Permalink to this headline">¶</a></h4>
<p>In two dimensions, the default initial configuration of geometries in ODL is</p>
<blockquote>
<div><div class="math">
<p><img src="../_images/math/126dd3e0e8be96b231831cd11d525a48d8b4d26c.png" alt="r(0) = \alpha
\begin{pmatrix}
    0 \\
    1
\end{pmatrix},
\ s(u) = u
\begin{pmatrix}
    1 \\
    0
\end{pmatrix}."/></p>
</div></div></blockquote>
<p>If a different initial detector position <img class="math" src="../_images/math/fb5edb5e3784122aa0feadc2d2ee225c489e76fb.png" alt="r(0) = \alpha (-\sin\psi, \cos\psi)^{\mathrm{T}}"/> is chosen, the initial detector axis is taken to be <img class="math" src="../_images/math/ed6c36609d1c108fd711813d145d2bb280ac3039.png" alt="s(1) = (\cos\psi, \sin\psi)"/> by default.</p>
<p>In three dimensions, there is no unique way to rotate one vector to another, which is why a convention is required in this case.
The standard configuration in 3d is</p>
<blockquote>
<div><div class="math">
<p><img src="../_images/math/8d6eba60c9386031b251a068acf4ad0b27f5f617.png" alt="r(0) =
\begin{pmatrix}
    0 \\
    1  \\
    0
\end{pmatrix},
\
s(1, 0) =
\begin{pmatrix}
    1 \\
    0  \\
    0
\end{pmatrix},
\
s(0, 1) =
\begin{pmatrix}
    0 \\
    0  \\
    1
\end{pmatrix}"/></p>
</div></div></blockquote>
<p>for initial detector position and axes.
Here the zero parameter in <img class="math" src="../_images/math/5bb39706095aad93cc8690abb69e60d21b0dcb4b.png" alt="r(0)"/> can have one or more components, and if the detector is only one-dimensional, we use <img class="math" src="../_images/math/4bfd8c50fbc02ef8ce4604a601214b6327f3221a.png" alt="s(0) = (1, 0, 0)^{\mathrm{T}}"/> only.</p>
<div class="figure align-center" id="id2">
<a class="reference internal image-reference" href="../_images/coord_sys_3d.svg"><img alt="../_images/coord_sys_3d.svg" src="../_images/coord_sys_3d.svg" width="50%" /></a>
<p class="caption"><span class="caption-text">Default 3D coordinate system.
The configuration is chosen such that the detector axes coincide with the standard <img class="math" src="../_images/math/a59f68a4202623bb859a7093f0316bf466e6f75d.png" alt="x"/> and <img class="math" src="../_images/math/683f2dd9129a91d21aaf1c04afa6f78b39d4cb0a.png" alt="z"/> coordinate axes.</span></p>
</div>
<p>The transition to other initial states is done by rotating the whole system, and the rotation is either explicitly specified or computed to rotate one vector to another.
Let <img class="math" src="../_images/math/d53e312933db58fc6074594a5cd6394be0fe8862.png" alt="v_1, ..., v_K \in \mathbb{R}^3"/> be the vectors defining the initial configuration of a 3d geometry, and <img class="math" src="../_images/math/84bc4bbfde11782639946a6e521efbe820bd0420.png" alt="v_1^{(\text{def})}, ..., v_K^{(\text{def})}"/> are their default values.
The rotated configuration is given by</p>
<blockquote>
<div><div class="math">
<p><img src="../_images/math/d5974e7218b42370541aa41dece2d40edf518de7.png" alt="v_k = R^{(\mathrm{i})}\, v_k^{(\text{def})},"/></p>
</div></div></blockquote>
<p>i.e., <em>all vectors are transformed by the same rotation</em>.
The matrix <img class="math" src="../_images/math/73ce6eb2bf1d08948bccc1d924a90fa943afebf7.png" alt="R^{(\mathrm{i})} \in \mathbb{R}^{3 \times 3}"/> is chosen to rotate the first vector from its default <img class="math" src="../_images/math/34b502c21377b9477df6c84baf02a2d675cb9292.png" alt="v_1^{(\text{def})}"/> to its actual value <img class="math" src="../_images/math/8fecd40ca8eb7e61734850b21956deba20be3066.png" alt="v_1"/>, i.e.,</p>
<blockquote>
<div><div class="math">
<p><img src="../_images/math/170bd1e00b1577b35e5bb6f13b9b0bf27855491f.png" alt="R^{(\mathrm{i})} v_1^{(\text{def})} = v_1."/></p>
</div></div></blockquote>
<p>Since the rotation <img class="math" src="../_images/math/a2f4fd4f20025ea2be4ff646cafa0506e6e09269.png" alt="R^{(\mathrm{i})}"/> is not uniquely determined, we choose to perform a rotation in the plane spanned by <img class="math" src="../_images/math/34b502c21377b9477df6c84baf02a2d675cb9292.png" alt="v_1^{(\text{def})}"/> and <img class="math" src="../_images/math/8fecd40ca8eb7e61734850b21956deba20be3066.png" alt="v_1"/>, making use of <a class="reference external" href="https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula">Rodrigues’ rotation formula</a>:</p>
<blockquote>
<div><div class="math">
<p><img src="../_images/math/c76769d9369fa0da050c9ee069688b454ce26ef8.png" alt="a &amp;= \frac{v_1^{(\text{def})} \times v_1}{\big| v_1^{(\text{def})} \times v_1 \big|},\ \cos\beta = \langle v_1^{(\text{def})},\, v_1 \rangle,

R^{(\mathrm{i})} v &amp;= \cos\beta v + \sin\beta (a \times v) + (1 - \cos\beta)\langle a,\, v \rangle a."/></p>
</div></div></blockquote>
<p>This construction becomes unstable when <img class="math" src="../_images/math/ba5f182155187f58e05cc98f92a692fe0b078a88.png" alt="v_1^{(\text{def})} \approx v_1"/>.
Therefore, if <img class="math" src="../_images/math/ff84913c06ae5ae5c2ec0a5d7a11ed8e7244130b.png" alt="\big\| v_1^{(\text{def})} - v_1 \big\| &lt; \delta"/> for a threshold <img class="math" src="../_images/math/a702e781dfc76762a3a132c2031fba8898430925.png" alt="\delta"/>, we take <img class="math" src="../_images/math/0615f916ebe8284b995529a2bf6eaff1e528ff0f.png" alt="v_1 = v_1^{(\text{def})}"/>.</p>
<p>Below are some concrete examples for how this computation is done in practice.
For a list of implemented geometries, check the API documentation of the <code class="docutils literal notranslate"><span class="pre">odl.tomo.geometry</span></code> subpackage.</p>
</div>
<div class="section" id="parallel3deulergeometry">
<h4><a class="reference internal" href="../generated/odl.tomo.geometry.parallel.Parallel3dEulerGeometry.html#odl.tomo.geometry.parallel.Parallel3dEulerGeometry" title="odl.tomo.geometry.parallel.Parallel3dEulerGeometry"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Parallel3dEulerGeometry</span></code></a><a class="headerlink" href="#parallel3deulergeometry" title="Permalink to this headline">¶</a></h4>
<p>In this geometry, the motion parameters are two or three Euler angles, and the detector is two-dimensional and flat.
The handle <img class="math" src="../_images/math/8fecd40ca8eb7e61734850b21956deba20be3066.png" alt="v_1"/> for the initial rotation is the initial detector position, provided as <code class="docutils literal notranslate"><span class="pre">det_pos_init</span></code> parameter.
Its default value is <img class="math" src="../_images/math/4dc02195fad6c4c1598a8db02a631886b0d85ed7.png" alt="v_1^{(\text{def})} = (0, 1, 0)^{\mathrm{T}}"/>.</p>
</div>
<div class="section" id="parallel3daxisgeometry">
<h4><a class="reference internal" href="../generated/odl.tomo.geometry.parallel.Parallel3dAxisGeometry.html#odl.tomo.geometry.parallel.Parallel3dAxisGeometry" title="odl.tomo.geometry.parallel.Parallel3dAxisGeometry"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Parallel3dAxisGeometry</span></code></a><a class="headerlink" href="#parallel3daxisgeometry" title="Permalink to this headline">¶</a></h4>
<p>This geometry, like all subclasses of <a class="reference internal" href="../generated/odl.tomo.geometry.geometry.AxisOrientedGeometry.html#odl.tomo.geometry.geometry.AxisOrientedGeometry" title="odl.tomo.geometry.geometry.AxisOrientedGeometry"><code class="xref any py py-class docutils literal notranslate"><span class="pre">AxisOrientedGeometry</span></code></a>, has a fixed symmetry axis, provided as <code class="docutils literal notranslate"><span class="pre">axis</span></code> parameter.
Its motion parameter is a single rotation angle around this axis.
The initial orientation handle <img class="math" src="../_images/math/8fecd40ca8eb7e61734850b21956deba20be3066.png" alt="v_1"/> is the symmetry axis, with default value <img class="math" src="../_images/math/fcefd0965b267c56212ac941a3d0808223cc208e.png" alt="v_1^{(\text{def})} = (0, 0, 1)^{\mathrm{T}}"/>.</p>
</div>
<div class="section" id="coneflatgeometry">
<h4><a class="reference internal" href="../generated/odl.tomo.geometry.conebeam.ConeFlatGeometry.html#odl.tomo.geometry.conebeam.ConeFlatGeometry" title="odl.tomo.geometry.conebeam.ConeFlatGeometry"><code class="xref any py py-class docutils literal notranslate"><span class="pre">ConeFlatGeometry</span></code></a><a class="headerlink" href="#coneflatgeometry" title="Permalink to this headline">¶</a></h4>
<p>The 3D cone beam geometry with circular acquisition curve is also an <a class="reference internal" href="../generated/odl.tomo.geometry.geometry.AxisOrientedGeometry.html#odl.tomo.geometry.geometry.AxisOrientedGeometry" title="odl.tomo.geometry.geometry.AxisOrientedGeometry"><code class="xref any py py-class docutils literal notranslate"><span class="pre">AxisOrientedGeometry</span></code></a>.
Here, the symmetry axis is perpendicular to the source and detector circles (which can be different but lie in the same plane).
Its motion parameter is a single angle that parametrizes the position of the source on the circle, and the detector lies opposite of the source point.
As in <a class="reference internal" href="../generated/odl.tomo.geometry.parallel.Parallel3dAxisGeometry.html#odl.tomo.geometry.parallel.Parallel3dAxisGeometry" title="odl.tomo.geometry.parallel.Parallel3dAxisGeometry"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Parallel3dAxisGeometry</span></code></a>, the initial orientation is determined by the symmetry axis, with the same default.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/circular_cone3d_sketch.svg"><img alt="../_images/circular_cone3d_sketch.svg" src="../_images/circular_cone3d_sketch.svg" width="75%" /></a>
</div>
</div>
</div>
<div class="section" id="detector-properties">
<h3>Detector properties<a class="headerlink" href="#detector-properties" title="Permalink to this headline">¶</a></h3>
<p>The detector model in ODL is intended to be very flexible and able to encode many different types of detectors.
Besides the obvious flat 2d detectors, it is also possible to implement curved detectors as used in medical CT, PET detector rings, Compton cameras, point-like transducers etc.</p>
<p>Nevertheless, names and concepts are centered around the surface-like detector model since it is most widely used in practice.
In particular, the function <img class="math" src="../_images/math/ad98dbf41221f72019aa9b763c6a12a7f482fc8c.png" alt="s(u)"/> mapping a detector parameter to a point on the detector (e.g. two angles to a point on a curved detector surface) is called <code class="docutils literal notranslate"><span class="pre">surface</span></code>.</p>
<p>There are two methods that can be implemented for additional functionality, <code class="docutils literal notranslate"><span class="pre">surface_deriv</span></code> and <code class="docutils literal notranslate"><span class="pre">surface_measure</span></code>.
The former should be the derivative map</p>
<blockquote>
<div><div class="math">
<p><img src="../_images/math/874662558c482dde77c5c2b7e90e4bce33918bab.png" alt="&amp; \partial s : D \to TM_{\mathrm{d}},

&amp; (\partial s)_i = \frac{\partial s}{\partial u_i}"/></p>
</div></div></blockquote>
<p>from <img class="math" src="../_images/math/3cf5aa5abe312e6fd4996975341a43aa566e8d8d.png" alt="D"/> to the tangent bundle <img class="math" src="../_images/math/ae1811e2e8523ef61e08dba79e56afe406de54ec.png" alt="TM_{\mathrm{d}}"/> of the detector manifold <img class="math" src="../_images/math/0242d7562c7c6cfc79929a1ce1fea1ad6e0e7e76.png" alt="M_{\mathrm{d}}"/>.
This means that for each fixed <img class="math" src="../_images/math/198a603d07c2c0fa7853a8018396b47382b5f408.png" alt="u \in D"/>, the vectors <img class="math" src="../_images/math/019c0f5ff108ea1031717676981031fa1c68c1d7.png" alt="(\partial s(u))_i"/> are <a class="reference external" href="https://en.wikipedia.org/wiki/Tangent_space">tangent vectors</a> at the point <img class="math" src="../_images/math/15cdc62bbd7116c6549a04d770b63b0242af43bb.png" alt="s(u) \in M_{\mathrm{d}}"/>.
These vectors form a local coordinate system for <img class="math" src="../_images/math/0242d7562c7c6cfc79929a1ce1fea1ad6e0e7e76.png" alt="M_{\mathrm{d}}"/> at <img class="math" src="../_images/math/ad98dbf41221f72019aa9b763c6a12a7f482fc8c.png" alt="s(u)"/> if the matrix <img class="math" src="../_images/math/df938129b73741535fcb14709a7b64f80fe0035a.png" alt="\partial s(u)"/> is not rank-deficient.</p>
<p>This derivative can be used to define a surface measure <img class="math" src="../_images/math/4d71d39f877f0075e7ee71fb1b96b2ee45b21bdf.png" alt="\mathrm{d}\mu(u)"/> such that one can integrate over the detector surface with correct weights.
For a one-dimensional detector and a single parameter <img class="math" src="../_images/math/35de16d2b61e065c3c6d2986201679638bf2b2db.png" alt="u \in \mathbb{R}"/>, the measure is given by the <a class="reference external" href="https://en.wikipedia.org/wiki/Curve#Length_of_a_curve">length of the tangent vector</a>,</p>
<blockquote>
<div><div class="math">
<p><img src="../_images/math/a7c2e76ddcf06c256cbc81a98338c298d1d7d413.png" alt="\mathrm{d}\mu(u) = |s'(u)|\, \mathrm{d}u."/></p>
</div></div></blockquote>
<p>On a two-dimensional detector with two parameters, the weight factor is the length of the <a class="reference external" href="https://en.wikipedia.org/wiki/Surface_area">cross product of the two canonical tangent vectors</a>,</p>
<blockquote>
<div><div class="math">
<p><img src="../_images/math/a571c6b80a51c43c3944cd59950487adc5fba539.png" alt="\mathrm{d}\mu(u) = \big| (\partial s(u))_1 \times (\partial s(u))_2 \big|\, \mathrm{d}u."/></p>
</div></div></blockquote>
<p>Thus, in these two cases, a default implementation for <code class="docutils literal notranslate"><span class="pre">surface_measure</span></code> is provided as above.
Subclasses that do not fall into these categories should override <code class="docutils literal notranslate"><span class="pre">surface_measure</span></code>.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="functional_guide.html" class="btn btn-neutral float-right" title="Functional" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="vectorization_guide.html" class="btn btn-neutral" title="Vectorized functions" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015-2017, ODL development group

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>